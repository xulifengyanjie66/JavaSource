```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
这段获取hashCode代码为啥要这样写?

hash()函数通过key.hashCode() ^ (h >>> 16)计算哈希值，‌核心目的是优化哈希值的分布，减少哈希冲突‌。具体原因和实现逻辑如下：

1. 背景：哈希冲突与低位碰撞
   哈希表通常用取模运算（如index = hash % tableSize）定位桶的位置。当哈希表的容量较小时（例如默认容量16），‌取模运算仅依赖哈希值的低位‌：

如果对象的hashCode()主要集中在高位变化，而低位重复度高，会导致大量哈希冲突。
例如：

java
Copy Code
// 假设两个对象的哈希码分别为：
Object1.hashCode() = 0x12345678
Object2.hashCode() = 0xABCD5678

// 哈希表容量为16时，取模运算用低4位：
0x12345678 % 16 = 0x8 → 桶8
0xABCD5678 % 16 = 0x8 → 桶8 → 冲突！
尽管高位不同，但低位相同会导致冲突。

2. 解决方案：混合高位与低位信息
   通过 ‌hashCode() ^ (hashCode() >>> 16)‌ 将哈希码的高16位与低16位混合：

‌高位右移‌：h >>> 16 将高16位移动到低16位。
‌异或（XOR）‌：将原始低16位与高位信息混合，生成新的低16位。
操作步骤：
‌计算原始哈希码‌：h = key.hashCode()（32位）。
‌右移16位‌：h >>> 16 → 高16位移动到低16位，高16位补零。
‌异或运算‌：h ^ (h >>> 16) → 将高位信息“扩散”到低位。
示例：
java
Copy Code
h = 0x12345678
h >>> 16 = 0x00001234

// 异或后：
0x12345678 ^ 0x00001234 = 0x1234444C

// 取模运算时，低16位是0x444C（不再是重复的0x5678）→ 减少冲突。
3. 为什么用异或（XOR）而不是其他位运算？
   ‌异或的特性‌：
   异或能保证高低位信息‌均匀混合‌，避免偏向0或1（与运算偏向0，或运算偏向1）。
   ‌效率‌：
   异或是单周期CPU指令，性能最优。
4. 对哈希表性能的影响
   ‌减少冲突‌：混合高位信息后，即使哈希表容量小，低位的变化也更丰富。
   ‌负载因子优化‌：降低哈希冲突后，哈希表扩容的频率减少，性能提升。
   实验验证（Java HashMap默认实现）：
   java
   Copy Code
   // 不混合高低位的哈希值
   int hashCode1 = 0x12345678;
   int bucket1 = hashCode1 & (15); // 0x8

// 混合高低位后的哈希值
int mixedHash1 = hashCode1 ^ (hashCode1 >>> 16); // 0x1234444C
int bucket2 = mixedHash1 & (15); // 0xC → 避免冲突
5. 总结：设计意图
   步骤	作用	结果
   h = key.hashCode()	获取对象原始哈希码	32位整数
   h >>> 16	将高16位移动到低16位	高16位信息参与低位混合
   h ^ (h >>> 16)	高低位信息混合	哈希值分布更均匀
   通过这种方式，Java的哈希函数在保持高效率的同时，显著降低了哈希冲突的概率。